Reflection

In this course, the main challenge I tackled was building a program to manage contact information and then writing tests to make sure everything worked correctly. The goal wasn’t just to get the program running, but to make sure it was reliable and could be maintained or expanded later. I also had to think about how to test the program properly so I could catch mistakes before they became bigger problems.

To get started, I broke the project down into smaller pieces and focused on writing clean, organized code. Understanding data structures helped a lot — knowing how to store and access contact data efficiently made things smoother. I used lists and basic logic to keep track of the data, and unit tests helped me make sure each part worked the way it was supposed to.

I definitely hit a few roadblocks along the way. Sometimes a test would fail even though I thought the code was fine. Other times I’d realize I misunderstood a requirement and had to go back and change things. What helped was taking a step back, reviewing what the test was actually checking, and looking at things line by line until I figured it out.

This project changed how I think about software design. I used to focus more on just making things work, but now I’m paying more attention to how the code is structured, how easy it is to read, and how future-proof it is. I’ve started writing code that’s easier to follow and update, even if someone else has to jump in later (or even if I forget what I did a few weeks down the line).

Overall, this course helped me understand how to build programs that are not only functional but also maintainable and solidly tested — which is a skill I know I’ll keep using.
